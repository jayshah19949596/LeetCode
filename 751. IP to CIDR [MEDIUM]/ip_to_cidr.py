"""
751. IP to CIDR [MEDIUM]
https://leetcode.com/problems/ip-to-cidr

### 1. Question Explanation:
----------------------------
Given the root of a binary search tree, return a balanced binary search tree with the same node values.
If there is more than one answer, return any of them.

### 2. Solution:
----------------------------
Reference: https://leetcode.com/problems/ip-to-cidr/solutions/3869475/simple-solution-beats-100-with-detailed-explanation/
Intuition:
ip address is essentially a 32-digit binary integer.
So this question is to ask, for a sub-interval within [2, 2^32-1].
How to divide this sub-interval to intervals with 2^k length efficiently.

Approach:
If [i,i+2^k−1], is a member of final answer, then because of the property of CIDR expression, "i" statisfies
1. i has ≥k trailing zeros, otherwise there will be numbers differs with "i" in higher digit positions.
2. include 2^k k more ips would not pass total nnn

So the algorithm is clear, whenever there is a start point "i".
Counting the number of trailing zeros "m".
Starting from "m", find the largest "k" that "2^k" do not pass remaining quota "n".

n -> n - 2^k
i -> i + 2^k
Starting from initial ip input

### 3. Complexity Analysis:
----------------------------
Time - O(LogN)
Space - O(1)
"""
from typing import List


class Solution:
    def ipToCIDR(self, ip: str, n: int) -> List[str]:
        def ip_to_bin(ip):
            binary = ["{:08b}".format(int(i)) for i in ip.split('.')]
            return "".join(binary)

        def bin_to_ip(bin):
            ip = [str(int(bin[i:i+8], 2)) for i in range(0, 32, 8)]
            return ".".join(ip)

        ans, cur_ip = [], ip_to_bin(ip)

        while n > 0:
            last_one = 31
            while last_one > -1 and cur_ip[last_one] != '1':
                last_one -= 1

            # "trailing_zero" many bits can be changed in "cur_ip"
            trailing_zero = 31 - last_one

            # If the number IPs generated by changing "trailing_zero" bits is greater than "n"
            # then we are going out of range and wasting some IPs
            # We need to reduce the number of bits that can change to not exceed "n".
            while 2 ** trailing_zero > n:
                trailing_zero -= 1

            ans.append(f"{bin_to_ip(cur_ip)}/{32 - trailing_zero}")
            n -= 2 ** trailing_zero  # Update "n"
            """
            Calculate the next IP to start with
            Next IP will have "1" to the left of "trailing_zero" in current IP and everything else "0"
            For example:
            Curr IP is 11111111000000000000000000000111
            Next IP is 11111111000000000000000000001000
            -----------------------------
            Curr IP is 11111111000000000000000000001000 
            Next IP is 11111111000000000000000000010000
            -----------------------------
            """
            nxt_ip = int(cur_ip, 2)+2**trailing_zero
            cur_ip = "{:032b}".format(nxt_ip)
        return ans
